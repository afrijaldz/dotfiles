'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var compilerSfc = require('@vue/compiler-sfc');
var compilerDom = require('@vue/compiler-dom');
var syntax = require('@fluent/syntax');

const serializer = new syntax.FluentSerializer();
function getText(entry) {
    entry.comment = null;
    return serializer.serializeEntry(entry).substring(entry.id.name.length + 3).trimEnd();
}
function getMessages$1(content) {
    return syntax.parse(content, { withSpans: false }).body
        .reduce((entries, entry) => {
        if (entry instanceof syntax.Message) {
            entries[entry.id.name] = getText(entry);
        }
        return entries;
    }, {});
}
function merge$1(ftlSource, messages) {
    const currentResourse = syntax.parse(ftlSource, { withSpans: true });
    for (const [key, value] of Object.entries(messages)) {
        const resourceString = `${key} = ${value}`;
        const resource = syntax.parse(resourceString, { withSpans: false });
        let updated = false;
        for (const message of currentResourse.body) {
            if (message instanceof syntax.Message && message.id.name === key) {
                updated = true;
                message.value = resource.body[0].value;
            }
        }
        if (!updated) {
            const newMessage = new syntax.Message(new syntax.Identifier(key), resource.body[0].value);
            currentResourse.body.push(newMessage);
        }
    }
    return syntax.serialize(currentResourse, { withJunk: true });
}

function getMessages(source) {
    const descriptor = getDescriptor(source);
    descriptor.customBlocks.sort((a, b) => {
        return a.loc.start.offset - b.loc.start.offset;
    });
    return extractFromCustomBlocks(descriptor.customBlocks);
}
function merge(source, locale, messages) {
    const parseResult = getDescriptor(source);
    let fluentBlock = parseResult.customBlocks
        .find(block => block.type === 'fluent' && block.attrs.locale === locale);
    if (fluentBlock != null) {
        const newBlockContent = merge$1(fluentBlock.content, messages);
        fluentBlock.content = newBlockContent;
    }
    else {
        fluentBlock = {
            type: 'fluent',
            attrs: {
                locale: locale
            },
            content: merge$1('', messages)
        };
    }
    // Write back
    const blocks = getBlocks(parseResult);
    return buildContent(fluentBlock, parseResult.source, blocks);
}
const decodeRE = /&(gt|lt|amp|apos|quot);/g;
const decodeMap = {
    gt: '>',
    lt: '<',
    amp: '&',
    apos: "'",
    quot: '"'
};
function getDescriptor(source) {
    return compilerSfc.parse(source, {
        sourceMap: false,
        ignoreEmpty: false,
        pad: false,
        compiler: {
            parse(template, options) {
                return compilerDom.parse(template, {
                    ...options,
                    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1])
                });
            },
            compile: compilerDom.compile
        }
    }).descriptor;
}
function extractFromCustomBlocks(blocks) {
    return blocks.map(block => {
        if (block.type !== 'fluent') {
            return undefined;
        }
        const locale = block.attrs.locale;
        if (locale == null || typeof locale !== 'string') {
            throw new Error('fluent custom block does not have locale specified');
        }
        return {
            locale,
            messages: getMessages$1(block.content)
        };
    }).filter(Boolean);
}
function getBlocks(descriptor) {
    const { template, script, styles, customBlocks } = descriptor;
    const blocks = [...styles, ...customBlocks];
    (template != null) && blocks.push(template);
    (script != null) && blocks.push(script);
    blocks.sort((a, b) => {
        return a.loc.start.offset - b.loc.start.offset;
    });
    return blocks;
}
function buildContent(blockToAdd, raw, blocks) {
    var _a;
    const EOL = (_a = /\r?\n|\r/g.exec(raw)) === null || _a === void 0 ? void 0 : _a[0];
    if (EOL == null) {
        // Empty input
        return raw;
    }
    let offset = 0;
    let inserted = false;
    let contents = [];
    let fluentOffset = -1;
    contents = blocks.reduce((contents, block, i) => {
        if (block.type === 'fluent' && block.attrs.locale === blockToAdd.attrs.locale) {
            contents = contents.concat(raw.slice(offset, block.loc.start.offset));
            contents = contents.concat(`${EOL}${blockToAdd.content}`);
            offset = block.loc.end.offset;
            inserted = true;
        }
        else {
            contents = contents.concat(raw.slice(offset, block.loc.end.offset));
            offset = block.loc.end.offset;
            if (block.type === 'fluent') {
                fluentOffset = contents.join('').length + '</fluent>'.length + EOL.length;
            }
        }
        return contents;
    }, contents);
    contents = contents.concat(raw.slice(offset, raw.length));
    let source = contents.join('');
    if (!inserted) {
        const content = `${EOL}<fluent locale="${blockToAdd.attrs.locale}">${EOL}${blockToAdd.content}</fluent>${EOL}`;
        if (fluentOffset !== -1) {
            source = source.slice(0, fluentOffset) + content + source.slice(fluentOffset);
        }
        else {
            source = source + content;
        }
    }
    return source;
}

exports.getFtlMessages = getMessages$1;
exports.getVueMessages = getMessages;
exports.mergeFtl = merge$1;
exports.mergeVue = merge;
